# LogReader v1.2 Specification

## Overview

Version 1.2 builds on the dynamic tag system from v1.1 with workflow enhancements focused on file management, real-time monitoring, and quick error detection.

---

## Priority Features (v1.2)

### 1. Recent Files List (File â†’ Recent)
**Priority: HIGH**

#### Requirements
- Display up to 10 most recently opened log files in File menu
- Show files in reverse chronological order (most recent first)
- Include full file paths with shortened display names
- Clear invalid/deleted files from list automatically
- Add "Clear Recent Files" option at bottom of submenu

#### User Stories
- As a user, I want to quickly reopen files I've worked with recently
- As a user, I want to switch between multiple log files without navigating the file system
- As a user, I want stale entries (deleted files) automatically removed

#### UI Design
```
File Menu:
  Open...              Ctrl+O
  Reload               Ctrl+R
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Recent Files        â–¶
    â””â”€ Submenu:
       1. vulkan_session_2025-01-15.log
       2. network_debug.log
       3. C:\Logs\app_startup.log
       ...
       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       Clear Recent Files
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Quit                 Ctrl+Q
```

#### Data Model
```python
@dataclass
class AppConfig:
    # Existing fields...
    recent_files: List[str] = field(default_factory=list)  # List of file paths
    max_recent_files: int = 10  # Configurable limit
```

#### Implementation Notes
- Store as list in JSON config: `"recent_files": ["/path/to/file1.log", ...]`
- On file open: Add to list, remove duplicates, trim to max length
- On menu show: Validate each path exists, remove invalid entries
- Menu item format: Show basename for local files, full path for distant paths
- Clicking entry: Call `_open_file(path)` directly

#### Edge Cases
- Empty recent list: Show "No Recent Files" (disabled)
- File deleted/moved: Skip entry, remove from config on next save
- Duplicate opens: Move to top of list (don't duplicate)
- Very long paths: Truncate middle with "..." (e.g., `C:\...\very\long\path\file.log`)

---

### 2. Tag Count in Filter Checkboxes
**Priority: HIGH**

#### Requirements
- Display entry count for each tag next to checkbox label
- Format: `TAG_NAME [count]` (e.g., `DEBUG [800]`, `ERROR [50]`)
- Update counts dynamically when:
  - New file is loaded
  - Search filter is applied
  - Other tag filters are toggled
- Counts reflect current search results (not total file)
- **Per-tag "Show Count" toggle in Tag Editor**:
  - Each tag has a "Show Count" checkbox in Tag Editor
  - When unchecked, that tag's count is hidden in filter UI
  - Default: ERROR and WARN show counts, others don't
  - Allows users to focus on important tags only

#### User Stories
- As a user, I want to see at a glance if there are any ERROR entries
- As a user, I want to know how many entries match my current search
- As a user, I want counts to update when I combine filters
- As a user, I want to hide counts for tags I don't care about (e.g., DEBUG)
- As a user, I want to focus on ERROR/WARN counts without visual clutter

#### UI Design

**Filter Display (with counts enabled for ERROR/WARN only):**
```
Filters:  â˜ DEBUG  â˜ INFO  â˜ WARN [92]  â˜‘ ERROR [15]  â˜ HEADER
```

**Filter Display (with all counts enabled):**
```
Filters:  â˜ DEBUG [1243]  â˜ INFO [856]  â˜ WARN [92]  â˜‘ ERROR [15]  â˜ HEADER [2]
```

When ERROR is checked and search is "timeout":
```
Filters:  â˜ DEBUG  â˜ INFO  â˜ WARN [2]  â˜‘ ERROR [8]  â˜ HEADER
```

**Tag Editor Dialog (updated):**
```
Tag Editor
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tag Name  â”‚ Tag Color â”‚ Message Color â”‚ Show Count â”‚ Preview   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ DEBUG     â”‚ [Cyan]    â”‚ [White]       â”‚ â˜          â”‚ DEBUG ... â”‚
â”‚ INFO      â”‚ [Green]   â”‚ [White]       â”‚ â˜          â”‚ INFO ...  â”‚
â”‚ WARN      â”‚ [Yellow]  â”‚ [White]       â”‚ â˜‘          â”‚ WARN ...  â”‚
â”‚ ERROR     â”‚ [Red]     â”‚ [White]       â”‚ â˜‘          â”‚ ERROR ... â”‚
â”‚ HEADER    â”‚ [Blue]    â”‚ [White]       â”‚ â˜          â”‚ HEADER ...â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  [Add Tag]  [Remove Tag]  [Reset to Defaults]  [OK]  [Cancel]
```

#### Data Model Changes
```python
@dataclass
class LogTag:
    name: str
    color: str
    enabled: bool = True
    order: int = 0
    message_color: str = "#FFFFFF"
    message_match_tag: bool = False
    show_count: bool = False  # NEW: Whether to show count in filter UI
```

**Default values for show_count:**
- DEBUG: False
- INFO: False
- WARN: True
- ERROR: True
- HEADER: False
- FOOTER: False

#### Implementation Notes
- Count calculation happens in `_apply_filters()` or separate method
- Store counts in: `Dict[str, int]` mapping tag name to count
- Update checkbox labels based on `tag.show_count` setting
- Performance: Calculate during filter pass (single iteration)

```python
def _update_tag_counts(self):
    """Update tag counts in filter checkboxes."""
    # Count entries by tag (respecting current search filter)
    tag_counts: Dict[str, int] = {}

    with self._entries_lock:
        for entry in self._log_entries:
            # Apply search filter if active
            if self._search_text and self._search_text.lower() not in entry.message.lower():
                continue

            # Increment count for this tag
            tag_name = entry.level.value
            tag_counts[tag_name] = tag_counts.get(tag_name, 0) + 1

    # Update checkbox labels (conditionally show counts)
    for tag_name, checkbox in self._filter_checkboxes.items():
        count = tag_counts.get(tag_name, 0)

        # Check if this tag should show count
        tag = ConfigManager.get_or_create_tag(tag_name)
        if tag.show_count:
            checkbox.setText(f"{tag_name} [{count}]")
        else:
            checkbox.setText(tag_name)
```

#### Tag Editor Implementation
Add "Show Count" column to Tag Editor table:

```python
class TagEditorDialog(QDialog):
    def __init__(self, parent=None):
        # Table with 5 columns now (was 4)
        self._table.setColumnCount(5)
        self._table.setHorizontalHeaderLabels([
            "Tag Name",
            "Tag Color",
            "Message Color",
            "Show Count",  # NEW COLUMN
            "Preview"
        ])

    def _load_tags(self):
        """Load tags into table."""
        tags = ConfigManager.load_tags()
        self._table.setRowCount(len(tags))

        for row, tag in enumerate(tags):
            # ... existing columns ...

            # Show Count checkbox (column 3)
            count_checkbox = QCheckBox()
            count_checkbox.setChecked(tag.show_count)
            count_checkbox.stateChanged.connect(lambda state, r=row: self._on_show_count_changed(r, state))
            count_widget = QWidget()
            count_layout = QHBoxLayout(count_widget)
            count_layout.addWidget(count_checkbox)
            count_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
            count_layout.setContentsMargins(0, 0, 0, 0)
            self._table.setCellWidget(row, 3, count_widget)

    def _on_show_count_changed(self, row: int, state: int):
        """Handle show count checkbox toggle."""
        tag_name = self._table.item(row, 0).text()
        show_count = (state == Qt.CheckState.Checked.value)

        # Update tag in memory
        tags = ConfigManager.load_tags()
        for tag in tags:
            if tag.name == tag_name:
                tag.show_count = show_count
                break

        # Don't save here, wait for OK button
        self._tags_modified = True
```

#### Edge Cases
- No entries: All counts show `[0]` (if show_count enabled)
- Search with no results: All counts show `[0]` (if show_count enabled)
- Unknown tags discovered: Default to `show_count=False`, auto-created tags don't show counts initially
- Large files: Ensure counting doesn't block UI (use thread if needed)
- Tag Editor closed with OK: Refresh filter checkboxes to reflect show_count changes
- Migration from v1.1: Default `show_count=True` only for WARN and ERROR tags

---

### 3. Live Tail Mode (Watch File for Changes)
**Priority: HIGH**

#### Requirements
- Toggle live tail mode via menu: `View â†’ Live Tail Mode` (or toolbar button)
- When enabled:
  - Watch current file for modifications
  - Auto-reload and append new entries
  - Auto-scroll to bottom (optional, user preference)
  - Show notification when new entries arrive
- When disabled: Stop watching, normal static view

#### User Stories
- As a user, I want to watch a log file in real-time as my application writes to it
- As a user, I want to be notified when new entries appear
- As a user, I want the option to auto-scroll or stay at current position

#### UI Design

**Menu:**
```
View Menu:
  Live Tail Mode       â˜  (checkable action)
  Auto-Scroll          â˜  (enabled only when tail mode active)
```

**Toolbar Button (optional):**
```
[ğŸ“¡ Live] (toggle button, green when active)
```

**Notification:**
```
Status bar: "Live Tail: 15 new entries added" (temporary, 3 seconds)
```

**System Tray (future enhancement):**
```
Show balloon notification when app is minimized and new entries arrive
```

#### Data Model
```python
@dataclass
class AppConfig:
    # Existing fields...
    live_tail_enabled: bool = False
    live_tail_auto_scroll: bool = True  # Auto-scroll to bottom
    live_tail_poll_interval: int = 1000  # milliseconds
```

#### Implementation Notes

**File Watching Strategy:**
Use `QFileSystemWatcher` to monitor file changes:

```python
from PyQt6.QtCore import QFileSystemWatcher

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self._file_watcher = QFileSystemWatcher()
        self._file_watcher.fileChanged.connect(self._on_file_changed)
        self._tail_mode_active = False
        self._last_file_size = 0

    def _enable_tail_mode(self):
        """Enable live tail monitoring."""
        if not self._current_file_path:
            return

        self._tail_mode_active = True
        self._last_file_size = Path(self._current_file_path).stat().st_size
        self._file_watcher.addPath(self._current_file_path)
        self._update_status("Live Tail: Active")

    def _disable_tail_mode(self):
        """Disable live tail monitoring."""
        self._tail_mode_active = False
        if self._current_file_path:
            self._file_watcher.removePath(self._current_file_path)
        self._update_status("Live Tail: Inactive")

    def _on_file_changed(self, path: str):
        """Handle file modification event."""
        if not self._tail_mode_active:
            return

        # Check if file grew (new data appended)
        current_size = Path(path).stat().st_size
        if current_size <= self._last_file_size:
            # File was truncated or replaced, do full reload
            self._on_reload_clicked()
            return

        # Read only new bytes
        new_bytes = current_size - self._last_file_size
        self._append_new_entries(path, self._last_file_size, new_bytes)
        self._last_file_size = current_size

    def _append_new_entries(self, file_path: str, offset: int, num_bytes: int):
        """Read and parse new entries from file."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                f.seek(offset)
                new_data = f.read(num_bytes)

            # Parse new lines
            new_entries = self._parse_incremental(new_data)

            if new_entries:
                with self._entries_lock:
                    self._log_entries.extend(new_entries)

                self._apply_filters()
                self._update_tag_counts()
                self._update_status(f"Live Tail: {len(new_entries)} new entries")

                # Auto-scroll if enabled
                if self._config.live_tail_auto_scroll:
                    self._log_table.scrollToBottom()

        except Exception as e:
            logger.error(f"Error appending new entries: {e}")
```

#### Incremental Parsing
- Maintain line buffer for partial lines (last line may be incomplete)
- On next update, prepend buffer to new data
- Parse complete lines, save remaining partial line

```python
self._tail_line_buffer = ""

def _parse_incremental(self, new_data: str) -> List[LogEntry]:
    """Parse new data, handling partial lines."""
    # Prepend any buffered partial line
    data = self._tail_line_buffer + new_data
    lines = data.split('\n')

    # Last line might be incomplete
    if not new_data.endswith('\n'):
        self._tail_line_buffer = lines[-1]
        lines = lines[:-1]
    else:
        self._tail_line_buffer = ""

    # Parse complete lines
    entries = []
    for line in lines:
        entry = self._parser.parse_line(line, len(self._log_entries) + len(entries) + 1)
        if entry:
            entries.append(entry)

    return entries
```

#### Edge Cases
- **File truncated/rotated**: Detect size decrease, do full reload
- **File deleted**: Remove from watcher, show error, disable tail mode
- **File locked**: Retry with delay, show warning
- **Rapid updates**: Debounce events (wait 100ms before processing)
- **Very large appends**: Parse in background thread
- **Filter active during tail**: New entries respect current filters
- **Search active during tail**: New matching entries appear

#### Performance Considerations
- Use incremental parsing (don't re-parse entire file)
- Debounce file change events (avoid processing every write)
- Consider max entry limit (e.g., keep last 100k entries, drop oldest)
- Profile memory usage for long-running tail sessions

---

## Implementation Plan

### Phase 1: Recent Files List (1-2 days)
**Dependencies**: None

**Tasks**:
1. Update `AppConfig` dataclass with `recent_files` list
2. Add `ConfigManager.add_recent_file(path)` method
3. Update `ConfigManager.load_config()` to validate recent file paths
4. Modify `_setup_menubar()` to create Recent Files submenu
5. Add `_update_recent_files_menu()` method
6. Call `add_recent_file()` in `_open_file()` success path
7. Add "Clear Recent Files" menu option
8. Test with 10+ files, deleted files, duplicates

**Files Modified**:
- `python/config.py` - Add recent files support
- `python/main_window.py` - Add Recent Files submenu

**Testing**:
- Open 10+ files, verify list truncates to 10
- Delete a recent file, verify it's removed on next menu show
- Open same file twice, verify no duplicate
- Clear recent files, verify menu updates

---

### Phase 2: Tag Count in Filters (1-2 days)
**Dependencies**: None

**Tasks**:
1. Update `LogTag` dataclass: Add `show_count: bool = False` field
2. Update `AppConfig._default_tags()`: Set `show_count=True` for WARN and ERROR only
3. Add `_update_tag_counts()` method to MainWindow
4. Call after: file load, filter change, search change, Tag Editor close
5. Update checkbox labels conditionally based on `tag.show_count`
6. Update Tag Editor: Add "Show Count" column (5th column)
7. Add checkbox widget to Tag Editor for show_count toggle
8. Handle show_count changes in Tag Editor dialog
9. Refresh filter UI when Tag Editor is closed with OK
10. Optimize counting (single pass through filtered entries)
11. Test with large files, verify performance

**Files Modified**:
- `python/config.py` - Add `show_count` field to LogTag
- `python/main_window.py` - Add tag counting logic with conditional display
- `python/tag_editor_dialog.py` - Add "Show Count" column

**Testing**:
- Load file with 10k+ entries, verify counts appear only for WARN/ERROR
- Toggle show_count in Tag Editor, verify filter UI updates
- Toggle filters, verify counts update for remaining entries
- Search for text, verify counts reflect search results
- Load file with no entries, verify counts show [0] where enabled
- Migration test: v1.1 config should default to WARN/ERROR counts only

---

### Phase 3: Live Tail Mode (3-4 days)
**Dependencies**: Phases 1 & 2 (for complete testing)

**Tasks**:
1. Add `QFileSystemWatcher` to MainWindow
2. Add View menu with "Live Tail Mode" and "Auto-Scroll" options
3. Implement `_enable_tail_mode()` and `_disable_tail_mode()`
4. Implement `_on_file_changed()` event handler
5. Add `_parse_incremental()` for partial line handling
6. Add `_append_new_entries()` method
7. Update status bar to show tail mode status
8. Add config options for tail mode preferences
9. Test with rapidly growing log files
10. Test edge cases: file truncation, deletion, rotation

**Files Modified**:
- `python/main_window.py` - Add tail mode UI and logic
- `python/config.py` - Add tail mode preferences

**Testing**:
- Enable tail, append to file externally, verify new entries appear
- Test auto-scroll behavior
- Truncate file during tail, verify reload
- Delete file during tail, verify graceful error
- Test with filters/search active during tail
- Test performance with rapid updates (100+ lines/sec)

---

## Testing Plan

### Unit Tests

**test_recent_files.py**:
```python
def test_add_recent_file():
    """Test adding files to recent list."""
    config = AppConfig()
    # Add 15 files, verify only last 10 kept
    # Add duplicate, verify moved to top
    # Add same file twice, verify no duplicate

def test_recent_files_validation():
    """Test validation of recent file paths."""
    # Create config with non-existent files
    # Load config, verify invalid paths removed
```

**test_tag_counts.py**:
```python
def test_tag_count_calculation():
    """Test tag count calculation."""
    # Create entries with various tags
    # Calculate counts, verify accuracy
    # Apply filter, verify counts update
    # Apply search, verify counts reflect search

def test_show_count_toggle():
    """Test show_count field behavior."""
    # Create tag with show_count=True, verify count displays
    # Create tag with show_count=False, verify count hidden
    # Toggle show_count in Tag Editor, verify filter UI updates
```

**test_tail_mode.py**:
```python
def test_incremental_parsing():
    """Test parsing of incremental data."""
    # Test complete lines
    # Test partial last line
    # Test multiple batches with partial lines

def test_file_growth_detection():
    """Test detection of new data."""
    # Append to file, verify new entries parsed
    # Truncate file, verify reload triggered
```

### Integration Tests

**test_integration_v1_2.py**:
```python
def test_recent_files_workflow():
    """Test complete recent files workflow."""
    # Open multiple files
    # Verify Recent menu updates
    # Click recent file, verify loads
    # Clear recent files, verify menu clears

def test_tail_mode_with_filters():
    """Test tail mode with active filters."""
    # Enable tail mode
    # Set ERROR filter
    # Append mixed entries to file
    # Verify only ERROR entries appear

def test_tag_counts_with_search():
    """Test tag counts update with search."""
    # Load file
    # Verify initial counts
    # Enter search text
    # Verify counts update to match search results
```

### Manual Testing Scenarios

1. **Recent Files**:
   - Open 15 different log files
   - Verify Recent menu shows only last 10
   - Delete one of the recent files from disk
   - Reopen app, verify deleted file removed from Recent menu
   - Open a recent file, verify it moves to top of list

2. **Tag Counts**:
   - Load large log file (50k+ entries)
   - Verify counts appear only for WARN and ERROR tags (default)
   - Open Tag Editor, enable show_count for DEBUG tag
   - Verify DEBUG count now appears in filter UI
   - Check ERROR filter, verify tag counts update
   - Enter search text, verify counts drop to matching entries
   - Clear all filters, verify counts return to totals
   - Disable show_count for ERROR in Tag Editor
   - Verify ERROR count disappears from filter UI

3. **Live Tail**:
   - Open a log file
   - Enable Live Tail Mode
   - Use external tool to append lines to file
   - Verify new entries appear in UI
   - Verify status bar shows "X new entries"
   - Truncate file externally, verify full reload
   - Delete file externally, verify error message

---

## Edge Cases & Error Handling

### Recent Files
- **Empty list**: Show "No Recent Files" (disabled menu item)
- **All files deleted**: Menu shows "No Recent Files"
- **Very long paths**: Truncate display (e.g., `C:\...\long\path\file.log`)
- **Network paths**: Handle UNC paths (`\\server\share\file.log`)
- **Permission denied**: Remove from list if can't access

### Tag Counts
- **Unknown tags**: Include in counts (auto-discovered tags)
- **Zero entries**: Show `[0]` for all tags
- **Very large counts**: Format with commas (e.g., `[1,243]`)
- **Performance**: If counting takes >100ms, run in thread

### Live Tail
- **File locked by writer**: Retry with delay (exponential backoff)
- **File rotated**: Detect and reload new file
- **Out of memory**: Implement max entries limit (configurable)
- **Corrupted data**: Skip invalid lines, log warning
- **Network file**: Disable tail mode (not supported for remote files)

---

## Configuration Changes

### JSON Schema Update

```json
{
  "version": "1.2",
  "last_directory": "/path/to/logs",
  "last_file": "/path/to/file.log",
  "recent_files": [
    "/path/to/file1.log",
    "/path/to/file2.log",
    "/path/to/file3.log"
  ],
  "max_recent_files": 10,
  "tags": [
    {
      "name": "DEBUG",
      "color": "#00FFFF",
      "enabled": true,
      "order": 0,
      "message_color": "#FFFFFF",
      "message_match_tag": false,
      "show_count": false
    },
    {
      "name": "INFO",
      "color": "#00FF00",
      "enabled": true,
      "order": 1,
      "message_color": "#FFFFFF",
      "message_match_tag": false,
      "show_count": false
    },
    {
      "name": "WARN",
      "color": "#FFFF00",
      "enabled": true,
      "order": 2,
      "message_color": "#FFFFFF",
      "message_match_tag": false,
      "show_count": true
    },
    {
      "name": "ERROR",
      "color": "#FF0000",
      "enabled": true,
      "order": 3,
      "message_color": "#FFFFFF",
      "message_match_tag": false,
      "show_count": true
    }
  ],
  "window": { "width": 1200, "height": 800 },
  "preferences": {
    "font_size": 9,
    "font_family": "Consolas",
    "theme": "light",
    "live_tail_enabled": false,
    "live_tail_auto_scroll": true,
    "live_tail_poll_interval": 1000
  }
}
```

### Migration from v1.1

```python
@classmethod
def _migrate_from_v1_1(cls, data: Dict[str, Any]) -> Dict[str, Any]:
    """Migrate v1.1 config to v1.2."""
    if data.get("version") == "1.1":
        # Add new fields with defaults
        data["version"] = "1.2"
        data["recent_files"] = []
        data["max_recent_files"] = 10

        # Add show_count field to all existing tags
        tags = data.get("tags", [])
        for tag in tags:
            # Default: only WARN and ERROR show counts
            tag_name = tag.get("name", "").upper()
            tag["show_count"] = (tag_name in ["WARN", "ERROR"])

        prefs = data.get("preferences", {})
        prefs["live_tail_enabled"] = False
        prefs["live_tail_auto_scroll"] = True
        prefs["live_tail_poll_interval"] = 1000
        data["preferences"] = prefs

    return data
```

---

## UI/UX Considerations

### Visual Feedback

1. **Recent Files**:
   - Show checkmark (âœ“) next to currently open file
   - Dim entries for deleted/inaccessible files (before removing)

2. **Tag Counts**:
   - Use different color for zero counts (dimmed gray)
   - Highlight non-zero ERROR/WARN counts (bold or red)

3. **Live Tail**:
   - Status bar shows green "Live" indicator when active
   - Flash/animate status bar when new entries arrive
   - Toolbar button changes color when active

### Performance Targets

- Recent files menu: Open in <10ms
- Tag count update: Complete in <50ms for 10k entries
- Live tail append: Process in <100ms for 100 new entries
- Memory usage: No leaks during 24hr tail session

---

## Future Enhancements (v1.3+)

These features are deferred but considered for future versions:

- **Tag Icons**: Visual icons in addition to colors
- **Bookmarks**: Mark important lines, navigate with N/P shortcuts
- **Export Filtered Results**: Save current view to new file
- **Custom Column Ordering**: Drag to reorder columns
- **Log Level Statistics**: Pie chart or bar graph of tag distribution
- **Split View**: Compare two log files side-by-side
- **Dark Mode Theme**: Alternative color scheme

---

## Success Criteria

Version 1.2 is complete when:

1. âœ… Recent Files menu shows last 10 opened files
2. âœ… Recent Files menu updates when file is opened
3. âœ… Invalid recent files are automatically removed
4. âœ… Tag counts appear next to filter checkboxes (conditionally based on show_count)
5. âœ… Tag counts default to WARN and ERROR only (show_count=True)
6. âœ… Tag Editor has "Show Count" column for toggling counts per tag
7. âœ… Tag counts update when filters or search changes
8. âœ… Filter UI updates when Tag Editor changes show_count settings
9. âœ… Live Tail Mode can be toggled via menu
10. âœ… New entries are detected and appended in real-time
11. âœ… Auto-scroll option works in tail mode
12. âœ… All unit tests pass
13. âœ… All integration tests pass
14. âœ… Manual testing scenarios completed successfully
15. âœ… Documentation updated (README, USER_GUIDE, CHANGELOG)

---

## Documentation Updates

### README.md
- Add v1.2 features to feature list
- Update screenshots showing tag counts
- Add Live Tail Mode to Quick Start Guide
- Update version history with v1.2 entry

### USER_GUIDE.md
- Add "Recent Files" section
- Add "Tag Counts" explanation
- Add "Live Tail Mode" detailed guide
- Update shortcuts table

### CHANGELOG.md
- Create v1.2 entry with all new features
- Document breaking changes (if any)
- List all bug fixes

### RELEASE_v1.2.md
- Create detailed release notes
- Include migration guide from v1.1
- Add known limitations (e.g., network files in tail mode)

---

## Risk Assessment

### Low Risk
- Recent Files: Simple config change, minimal code impact
- Tag Counts: Straightforward calculation, no architectural changes

### Medium Risk
- Live Tail Mode: File I/O complexity, potential performance issues
  - **Mitigation**: Thorough testing with various file sizes and update rates
  - **Mitigation**: Implement configurable limits (max entries, update interval)

### High Risk
- None identified for v1.2 scope

---

## Dependencies

### External Libraries
- **PyQt6**: Already in use, no new dependencies
- **QFileSystemWatcher**: Built into PyQt6, no additional install

### System Requirements
- No change from v1.1 (Python 3.10+, PyQt6)

---

## Timeline Estimate

**Total: 6-8 days**

- Day 1-2: Recent Files List (implementation + testing)
- Day 3-4: Tag Counts with Show Count toggle (implementation + testing)
- Day 5-7: Live Tail Mode (implementation + testing)
- Day 8: Documentation, final testing, release prep

---

## Questions for Stakeholder

1. **Recent Files**: Should we show file size or last modified date in menu?
2. **Tag Counts - Show Count**: âœ… Confirmed - Add per-tag "Show Count" toggle in Tag Editor (default: WARN/ERROR only)
3. **Tag Counts**: Should counts be highlighted in red/yellow for ERROR/WARN tags?
4. **Tag Counts**: Should very large counts be formatted with commas (e.g., `[1,243]`)?
5. **Live Tail**: Should we add system tray notification option?
6. **Live Tail**: Should there be a max entry limit to prevent memory issues? (Recommended: 100k entries)
7. **Live Tail**: Should tail mode persist across app restarts?
8. **Performance**: What's the acceptable delay for tag count updates on large files?

---

**End of Specification**
